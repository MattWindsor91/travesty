<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fn (travesty.Travesty_base_exts.Fn)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">travesty</a> &#x00BB; <a href="../index.html">Travesty_base_exts</a> &#x00BB; Fn</nav><header class="odoc-preamble"><h1>Module <code><span>Travesty_base_exts.Fn</span></code></h1><p>Miscellaneous function combinators.</p><p><code>Fn</code> contains various higher-order functions in the style of Base's <code>Fn</code> module.</p></header><nav class="odoc-toc"><ul><li><a href="#constant-predicates">Constant predicates</a></li><li><a href="#pointwise-liftings-of-operators">Pointwise liftings of operators</a></li><li><a href="#miscellaneous-combinators">Miscellaneous combinators</a></li><li><a href="#f#-style-function-composition-operator">F# style function composition operator</a></li></ul></nav><div class="odoc-content"><h3 id="constant-predicates"><a href="#constant-predicates" class="anchor"></a>Constant predicates</h3><p>These are convenience shorthands for <code>Base.Fn.const</code>.</p><div class="odoc-spec"><div class="spec value" id="val-always" class="anchored"><a href="#val-always" class="anchor"></a><code><span><span class="keyword">val</span> always : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>always x</code> is <code>true</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-never" class="anchored"><a href="#val-never" class="anchor"></a><code><span><span class="keyword">val</span> never : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>never x</code> is <code>false</code>.</p></div></div><h3 id="pointwise-liftings-of-operators"><a href="#pointwise-liftings-of-operators" class="anchor"></a>Pointwise liftings of operators</h3><p>These complement <code>Base.Fn.non</code>.</p><div class="odoc-spec"><div class="spec value" id="val-conj" class="anchored"><a href="#val-conj" class="anchor"></a><code><span><span class="keyword">val</span> conj : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>conj f g</code> lifts <code>&amp;&amp;</code> over predicates <code>f</code> and <code>g</code>. It is short-circuiting: <code>g</code> is never called if <code>f</code> returns false.</p><p>Examples:</p><pre><code>let is_zero = Int.(conj is_non_negative is_non_positive)</code></pre><pre><code>(* Short-circuiting: *)
conj always (fun () -&gt; failwith &quot;oops&quot;) () ;
(* --&gt; exception *)
conj never (fun () -&gt; failwith &quot;oops&quot;) ()

(* --&gt; false *)</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-disj" class="anchored"><a href="#val-disj" class="anchor"></a><code><span><span class="keyword">val</span> disj : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>disj f g</code> lifts <code>||</code> over predicates <code>f</code> and <code>g</code>. It is short-circuiting: <code>g</code> is never called if <code>f</code> returns true.</p><p>Examples:</p><pre><code>let is_not_zero = Int.(disj is_negative is_positive)</code></pre><pre><code>(* Short-circuiting: *)
disj never (fun () -&gt; failwith &quot;oops&quot;) () ;
(* --&gt; exception *)
disj always (fun () -&gt; failwith &quot;oops&quot;) ()

(* --&gt; false *)</code></pre></div></div><div class="odoc-spec"><div class="spec value" id="val-(&amp;&amp;&amp;)" class="anchored"><a href="#val-(&amp;&amp;&amp;)" class="anchor"></a><code><span><span class="keyword">val</span> (&amp;&amp;&amp;) : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>f &amp;&amp;&amp; g</code> is <code>conj f g</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-(|||)" class="anchored"><a href="#val-(|||)" class="anchor"></a><code><span><span class="keyword">val</span> (|||) : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>f ||| g</code> is <code>disj f g</code>.</p></div></div><h3 id="miscellaneous-combinators"><a href="#miscellaneous-combinators" class="anchor"></a>Miscellaneous combinators</h3><div class="odoc-spec"><div class="spec value" id="val-on" class="anchored"><a href="#val-on" class="anchor"></a><code><span><span class="keyword">val</span> on : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>f:<span>( <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'r</span></span></code></div><div class="spec-doc"><p><code>on lift x y ~f</code> lifts a binary function <code>f</code> using the lifter <code>lift</code>. It does the same thing as the `on` function from Haskell, but with arguments flipped to make sense without infixing.</p><p>Effectively, it's <code>Base.Comparable.lift</code>, but with a slightly different signature.</p><p>Example:</p><pre><code>let ints = on fst ~f:Int.equal (42, &quot;banana&quot;) (42, &quot;apple&quot;) in
let strs = on snd ~f:String.equal (42, &quot;banana&quot;) (42, &quot;apple&quot;) in
(ints, strs)

(* --&gt; true, false *)</code></pre></div></div><h3 id="f#-style-function-composition-operator"><a href="#f#-style-function-composition-operator" class="anchor"></a>F# style function composition operator</h3><p>This is in a separate module to reduce the ambiguity caused by its use.</p><div class="odoc-spec"><div class="spec module" id="module-Compose_syntax" class="anchored"><a href="#module-Compose_syntax" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Compose_syntax/index.html">Compose_syntax</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>