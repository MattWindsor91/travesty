<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S_non_monadic (travesty.Travesty_containers.Zipper_types.S_non_monadic)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../../index.html">travesty</a> &#x00BB; <a href="../../index.html">Travesty_containers</a> &#x00BB; <a href="../index.html">Zipper_types</a> &#x00BB; S_non_monadic</nav><h1>Module type <code>Zipper_types.S_non_monadic</code></h1><p><code>S_non_monadic</code> contains the core operations of a zipper, without any parametrisation over a particular failure monad.</p><nav class="toc"><ul><li><a href="#construction-and-destruction">Construction and destruction</a></li><li><a href="#querying-the-left-and-right-lists">Querying the left and right lists</a></li><li><a href="#predicates">Predicates</a></li><li><a href="#pushing">Pushing</a></li><li><a href="#peeking-and-popping">Peeking and popping</a></li><li><a href="#movement">Movement</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>'a t</span></code></dt><dd><p>The opaque type of zippers.</p></dd></dl><div><div class="spec include"><div class="doc"><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> Ppx_sexp_conv_lib.Sexpable.S1 <span class="keyword">with</span> <span class="keyword">type</span> <span>'a <a href="../index.html#module-type-S_non_monadic">S_non_monadic</a>.t</span> := <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></span></summary><dl><dt class="spec value" id="val-t_of_sexp"><a href="#val-t_of_sexp" class="anchor"></a><code><span class="keyword">val</span> t_of_sexp : <span>(Sexplib0__.Sexp.t <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> Sexplib0__.Sexp.t <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t" class="anchor"></a><code><span class="keyword">val</span> sexp_of_t : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> Sexplib0__.Sexp.t)</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> Sexplib0__.Sexp.t</code></dt></dl></details></div></div></div></div></div></div><section><header><h4 id="construction-and-destruction"><a href="#construction-and-destruction" class="anchor"></a>Construction and destruction</h4></header><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <span>left:<span><span class="type-var">'a</span> Base.list</span></span> <span>&#45;&gt;</span> <span>right:<span><span class="type-var">'a</span> Base.list</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>make ~left ~right</code> constructs a zipper with left list <code>left</code> and right list <code>right</code>.</p><p>These lists go directly into the zipper itself, so <code>left</code>, if non-empty, should be in the reverse order to how it should appear when fully rewound.</p></dd></dl><dl><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span><span class="type-var">'a</span> Base.list</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>of_list xs</code> converts a list <code>xs</code> to a fully-rewound zipper.</p><p>It is equivalent to <code>make</code> with an empty <code>left</code>.</p></dd></dl><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.list</span></code></dt><dd><p><code>to_list zipper</code> returns the list of _all_ items in the zipper, including those in the left list.</p><p>All items appear in the same order that they would take in the right list if the zipper was fully rewound. In other words, the left list appears first (in reverse order), followed by the right list (in forwards order).</p><p>To get only the items in the right list, use <code>right_list</code>; to get only the items in the left list (reversed), use <code>left_list</code>.</p></dd></dl></section><section><header><h4 id="querying-the-left-and-right-lists"><a href="#querying-the-left-and-right-lists" class="anchor"></a>Querying the left and right lists</h4></header><dl><dt class="spec value" id="val-left_list"><a href="#val-left_list" class="anchor"></a><code><span class="keyword">val</span> left_list : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.list</span></code></dt><dd><p><code>left_list zipper</code> gets the raw left list of the zipper: all of the already-processed items in reverse order.</p></dd></dl><dl><dt class="spec value" id="val-right_list"><a href="#val-right_list" class="anchor"></a><code><span class="keyword">val</span> right_list : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.list</span></code></dt><dd><p><code>right_list zipper</code> gets the right list of the zipper: all of the not-yet-processed items in forwards order.</p></dd></dl><dl><dt class="spec value" id="val-to_two_lists"><a href="#val-to_two_lists" class="anchor"></a><code><span class="keyword">val</span> to_two_lists : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.list</span> * <span><span class="type-var">'a</span> Base.list</span></code></dt><dd><p><code>to_two_lists zipper</code> is <code>(left_list zipper, right_list zipper)</code>.</p></dd></dl><dl><dt class="spec value" id="val-left_length"><a href="#val-left_length" class="anchor"></a><code><span class="keyword">val</span> left_length : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> Base.int</code></dt><dd><p><code>left_length zipper</code> gets the length of <code>zipper</code>'s left list.</p></dd></dl><dl><dt class="spec value" id="val-right_length"><a href="#val-right_length" class="anchor"></a><code><span class="keyword">val</span> right_length : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> Base.int</code></dt><dd><p><code>right_length zipper</code> gets the length of <code>zipper</code>'s right list.</p></dd></dl></section><section><header><h4 id="predicates"><a href="#predicates" class="anchor"></a>Predicates</h4></header><dl><dt class="spec value" id="val-is_at_start"><a href="#val-is_at_start" class="anchor"></a><code><span class="keyword">val</span> is_at_start : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> Base.bool</code></dt><dd><p><code>is_at_start zipper</code> tests whether <code>zipper</code>'s left list is empty.</p></dd></dl><dl><dt class="spec value" id="val-is_at_end"><a href="#val-is_at_end" class="anchor"></a><code><span class="keyword">val</span> is_at_end : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> Base.bool</code></dt><dd><p><code>is_at_end zipper</code> tests whether <code>zipper</code>'s right list is empty.</p></dd></dl></section><section><header><h4 id="pushing"><a href="#pushing" class="anchor"></a>Pushing</h4></header><dl><dt class="spec value" id="val-push"><a href="#val-push" class="anchor"></a><code><span class="keyword">val</span> push : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>value:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>push zipper ~value</code> pushes <code>value</code> into <code>zipper</code> at the cursor. The current cursor becomes the second item in the right list, and so on.</p></dd></dl><dl><dt class="spec value" id="val-push_left"><a href="#val-push_left" class="anchor"></a><code><span class="keyword">val</span> push_left : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>value:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>push_left zipper ~value</code> pushes <code>value</code> into <code>zipper</code> just to the left of the cursor.</p></dd></dl></section><section><header><h4 id="peeking-and-popping"><a href="#peeking-and-popping" class="anchor"></a>Peeking and popping</h4></header><dl><dt class="spec value" id="val-peek_opt"><a href="#val-peek_opt" class="anchor"></a><code><span class="keyword">val</span> peek_opt : <span>?&#8288;steps:Base.int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.option</span></code></dt><dd><p><code>peek_opt ?steps zipper</code> retrieves the cursor value without popping it from the zipper. If the cursor is empty, <code>None</code> is returned.</p><p>If <code>steps</code> is given, it shifts the effective cursor <code>steps</code> places forwards.</p></dd></dl><dl><dt class="spec value" id="val-pop"><a href="#val-pop" class="anchor"></a><code><span class="keyword">val</span> pop : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> Base.Or_error.t</span></code></dt><dd><p><code>pop zipper</code> returns an error if <code>zipper</code> has no cursor, or <code>Ok (a, zipper')</code> where <code>a</code> is <code>zipper</code>'s cursor and <code>zipper'</code> is the new zipper formed by removing <code>a</code>.</p></dd></dl><dl><dt class="spec value" id="val-pop_opt"><a href="#val-pop_opt" class="anchor"></a><code><span class="keyword">val</span> pop_opt : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span>)</span> Base.option</span></code></dt><dd><p><code>pop_opt zipper</code> behaves as <a href="index.html#val-pop"><code>pop</code></a>, but returns <code>None</code> if <code>zipper</code> has no cursor and <code>Some (a, zipper')</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-map_head"><a href="#val-map_head" class="anchor"></a><code><span class="keyword">val</span> map_head : <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span>f:<span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Base.option</span>)</span></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>map_head zipper ~f</code> maps <code>f</code> across the cursor of <code>zipper</code>, if it exists, and replaces the cursor with the result (or drops it if <code>f</code> returns <code>None</code>).</p></dd></dl></section><section><header><h4 id="movement"><a href="#movement" class="anchor"></a>Movement</h4></header><dl><dt class="spec value" id="val-step"><a href="#val-step" class="anchor"></a><code><span class="keyword">val</span> step : <span>?&#8288;steps:Base.int</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span><span><span class="type-var">'a</span> <a href="index.html#type-t">t</a></span> Base.Or_error.t</span></code></dt><dd><p><code>step ?steps zipper ~on_empty</code> takes one or more steps across <code>zipper</code>. The number of steps defaults to 1 (forwards), but can be given by <code>steps</code>; negative numbers step backwards through the zipper. If the number of steps exceeds the bounds of the zipper, an error is returned.</p></dd></dl></section></div></body></html>