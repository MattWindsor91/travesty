<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Helpers (travesty.Travesty.Traversable.Helpers)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">travesty</a> &#x00BB; <a href="../../index.html">Travesty</a> &#x00BB; <a href="../index.html">Traversable</a> &#x00BB; Helpers</nav><h1>Module <code>Traversable.Helpers</code></h1><p>Utility functions for building traversals.</p><nav class="toc"><ul><li><a href="#variants">Variants</a></li><li><a href="#fields">Fields</a></li></ul></nav></header><h3 class="heading">Parameters</h3><ul><li><code>M : Base.Monad.S</code></li></ul><h3 class="heading">Signature</h3><dl><dt class="spec type" id="type-traversal"><a href="#type-traversal" class="anchor"></a><code><span class="keyword">type</span> <span>'a traversal</span></code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#argument-1-M">M</a>.t</span></code></dt><dd><p><code>traversal</code> is shorthand for a traversal function over <code>M</code>.</p></dd></dl><section><header><h4 id="variants"><a href="#variants" class="anchor"></a>Variants</h4><p>Functions beginning <code>proc_variant</code> are useful for building traversable containers on top of Variantslib's <code>map</code> function.</p><p>Here's an example where we define a generic traversal function over a variant type using <a href="index.html#val-proc_variant1"><span>proc_variant1</span></a> and <a href="index.html#val-proc_variant3"><span>proc_variant3</span></a>, then use it to build a traversable container instance for inspecting and modifying a specific type of data regardless of variant.</p><pre><code class="ml">(* This type describes x86 operands: *)
type t =
  | Location of Location.t
  | Immediate of Disp.t
  | String of string
  | Typ of string
  | Bop of t * operator * t
[@@deriving variants]

(* We use the helpers to build an intermediate mapper... *)
module Base_map (M : Monad.S) = struct
  module F = Travesty.Traversable.Helpers (M)

  let rec map_m (x : t) ~location ~immediate ~string ~typ ~bop :
      t M.t =
    Variants.map x
      ~location:(F.proc_variant1 location)
      ~immediate:(F.proc_variant1 immediate)
      ~string:(F.proc_variant1 string)
      ~typ:
        (F.proc_variant1 typ)
        (* Note that this recursively folds down the operands, and
           that the [bop] function only receives the operator. *)
      ~bop:
        (F.proc_variant3 (fun (l, b, r) -&gt;
             let open M.Let_syntax in
             let%bind l' =
               map_m ~location ~immediate ~string ~typ ~bop l
             in
             let%bind b' = bop b in
             let%map r' =
               map_m ~location ~immediate ~string ~typ ~bop r
             in
             (l', b', r')))
end

(* ...then use it to build a traversable container over all of the
   symbols in an operand. *)
module On_symbols :
  Travesty.Traversable.S0_container
    with type t := t
     and type elt := string =
Travesty.Traversable.Make_container0 (struct
  type nonrec t = t

  module Elt = String

  module On_monad (M : Monad.S) = struct
    module B = Base_map (M)

    (* Recursively using other traversables: *)
    module L = Location.On_symbols.On_monad (M)
    module D = Disp.On_symbols.On_monad (M)

    let map_m t ~f =
      B.map_m t ~location:(L.map_m ~f)
        ~immediate:(D.map_m ~f) (* These don't contain symbols: *)
        ~string:M.return ~typ:M.return ~bop:M.return
  end
end)</code></pre></header><dl><dt class="spec value" id="val-proc_variant0"><a href="#val-proc_variant0" class="anchor"></a><code><span class="keyword">val</span> proc_variant0 : <span>Base.unit <a href="index.html#type-traversal">traversal</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'cont</span> Base.Variant.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'cont</span> <a href="index.html#argument-1-M">M</a>.t</span></code></dt><dd><p><code>proc_variant0 f variant</code> lifts a traversal <code>f</code> over a Variantslib nullary variant constructor <code>variant</code>.</p></dd></dl><dl><dt class="spec value" id="val-proc_variant1"><a href="#val-proc_variant1" class="anchor"></a><code><span class="keyword">val</span> proc_variant1 : <span><span class="type-var">'a</span> <a href="index.html#type-traversal">traversal</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'cont</span>)</span> Base.Variant.t</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'cont</span> <a href="index.html#argument-1-M">M</a>.t</span></code></dt><dd><p><code>proc_variant1 f variant a</code> lifts a traversal <code>f</code> over a Variantslib unary variant constructor <code>variant</code> with argument <code>a</code>.</p></dd></dl><dl><dt class="spec value" id="val-proc_variant2"><a href="#val-proc_variant2" class="anchor"></a><code><span class="keyword">val</span> proc_variant2 : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="index.html#type-traversal">traversal</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'cont</span>)</span> Base.Variant.t</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span class="type-var">'cont</span> <a href="index.html#argument-1-M">M</a>.t</span></code></dt><dd><p><code>proc_variant2 f variant a b</code> lifts a traversal <code>f</code> over a Variantslib binary variant constructor <code>variant</code> with arguments <code>a</code> and <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-proc_variant3"><a href="#val-proc_variant3" class="anchor"></a><code><span class="keyword">val</span> proc_variant3 : <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span> * <span class="type-var">'c</span>)</span> <a href="index.html#type-traversal">traversal</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span class="type-var">'cont</span>)</span> Base.Variant.t</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span class="type-var">'c</span> <span>&#45;&gt;</span> <span><span class="type-var">'cont</span> <a href="index.html#argument-1-M">M</a>.t</span></code></dt><dd><p><code>proc_variant3 f variant a b c</code> lifts a traversal <code>f</code> over a Variantslib ternary variant constructor <code>variant</code> with arguments <code>a</code>, <code>b</code>, and <code>c</code>.</p></dd></dl></section><section><header><h4 id="fields"><a href="#fields" class="anchor"></a>Fields</h4><p>The function <code>proc_field</code> is useful for building traversable containers on top of Fieldslib's <code>fold</code> function.</p><p>Here's an example where we define a generic traversal function over a record type using <a href="index.html#val-proc_field"><span>proc_field</span></a>, then use it to build a traversable container instance for inspecting and modifying a specific type of data inside the record.</p><pre><code class="ml">(* Type for holding x86 memory references. *)
type t =
  { seg: Reg.t option (* segment register *)
  ; disp: Disp.t option (* displacement *)
  ; base: Reg.t option (* base register *)
  ; index: Index.t option (* index *) }
[@@deriving fields]

(* First, build a generic traversal function (this isn't, itself, a
   Traversable)... *)
module Base_map (M : Monad.S) = struct
  module F = Travesty.Traversable.Helpers (M)

  let map_m indirect ~seg ~disp ~base ~index =
    Fields.fold ~init:(M.return indirect) ~seg:(F.proc_field seg)
      ~disp:(F.proc_field disp) ~base:(F.proc_field base)
      ~index:(F.proc_field index)
end

(* Now, we can build a traversable container instance. This one
   extracts symbols from memory references. *)
module On_symbols :
  Travesty.Traversable.S0_container
    with type t := t
     and type elt := string =
Travesty.Traversable.Make_container0 (struct
  type nonrec t = t

  module Elt = String
  module Set = String.Set

  module On_monad (M : Monad.S) = struct
    module B = Base_map (M)
    module D = Disp.On_symbols.On_monad (M)
    module O = My_option.On_monad (M)

    let map_m t ~f =
      B.map_m t (* Chained monadic traversal. *)
        ~disp:
          (O.map_m ~f:(D.map_m ~f))
          (* Segments, bases, and indices have no symbols. *)
        ~seg:M.return ~base:M.return ~index:M.return
  end
end)</code></pre></header><dl><dt class="spec value" id="val-proc_field"><a href="#val-proc_field" class="anchor"></a><code><span class="keyword">val</span> proc_field : <span><span class="type-var">'elt</span> <a href="index.html#type-traversal">traversal</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'cont</span> <a href="index.html#argument-1-M">M</a>.t</span> <span>&#45;&gt;</span> <span><span>(<span>[&gt; `Set_and_create ]</span>, <span class="type-var">'cont</span>, <span class="type-var">'elt</span>)</span> Base.Field.t_with_perm</span> <span>&#45;&gt;</span> <span><span class="type-var">'cont</span> <a href="index.html#argument-1-M">M</a>.t</span></code></dt><dd><p><code>proc_field f state field container original</code> lifts a traversal <code>f</code> to a form comparible with Fieldslib's <code>fold</code> function.</p></dd></dl></section></div></body></html>